{"hash":"2566cad9cfa9a67178201bd25df13b8fbe2cfb95","fesm2020":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional as Optional$1, Inject, NgModule } from '@angular/core';\nimport { FormGroup, FormArray, FormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { of } from 'rxjs';\nimport 'reflect-metadata';\n\nconst NGX_FORM_GENERATOR_ASYNC_VALIDATORS = new InjectionToken(\"NGX_FORM_GENERATOR_ASYNC_VALIDATORS\");\n\nclass GeneratedFormGroup extends FormGroup {\n    constructor(asyncValidators = []) {\n        super({});\n        this.asyncValidators = asyncValidators;\n    }\n    setConfig(config) {\n        this.config = config;\n        this._models = config.children;\n        this.setValidators(config.validators);\n        this.generateControls();\n    }\n    patchValue(value, options = {}) {\n        if (!value) {\n            return;\n        }\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const model = this._models.find(x => x.name === key);\n            this.controls[key].patchValue(value[model.key], { onlySelf: true, emitEvent: options.emitEvent });\n        }\n        this.updateValueAndValidity(options);\n    }\n    getRawValue() {\n        const rawValue = new this.config.instance();\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            rawValue[model.key] = control.getRawValue();\n        }\n        return rawValue;\n    }\n    getValidValue() {\n        const validValue = new this.config.instance();\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            validValue[model.key] = control.getValidValue();\n        }\n        return validValue;\n    }\n    shouldValidate() {\n        let parentValidation = true;\n        if (this.parent) {\n            parentValidation = this.parent.shouldValidate();\n        }\n        if (!this.config) {\n            return true;\n        }\n        return (this.config.validationOption || { isOptional: false }).isOptional ? false : parentValidation;\n    }\n    copy() {\n        const group = new GeneratedFormGroup();\n        group.setConfig(this.config);\n        return group;\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    generateControls() {\n        for (const control of this._models) {\n            let formControl;\n            if (control.formElementType === \"array\") {\n                formControl = new GeneratedFormArray(control, this.asyncValidators);\n            }\n            else if (control.formElementType === \"group\") {\n                formControl = new GeneratedFormGroup(this.asyncValidators);\n                formControl.setConfig(control);\n            }\n            else {\n                formControl = new GeneratedFormControl(control, this.asyncValidators);\n                formControl.setAsyncControlValidators(control.asyncValidators);\n            }\n            super.addControl(control.name, formControl);\n        }\n    }\n}\nGeneratedFormGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup, deps: [{ token: NGX_FORM_GENERATOR_ASYNC_VALIDATORS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nGeneratedFormGroup.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Optional$1\n                }, {\n                    type: Inject,\n                    args: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n                }] }]; } });\nclass GeneratedFormArray extends FormArray {\n    constructor(model, asyncValidators = []) {\n        super(model.defaultValue ?? [], model.validators);\n        this.model = model;\n        this.asyncValidators = asyncValidators;\n    }\n    push(value) {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.push(control);\n    }\n    insert(index, value) {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.insert(index, control);\n    }\n    at(index) {\n        return super.at(index);\n    }\n    patchValue(value, options = {}) {\n        if (!value) {\n            return;\n        }\n        let i = 0;\n        for (const data of value) {\n            if (i >= this.controls.length) {\n                this.push(null);\n            }\n            this.at(i).patchValue(data, { onlySelf: true, emitEvent: options.emitEvent });\n            ++i;\n        }\n        this.updateValueAndValidity(options);\n    }\n    getRawValue() {\n        return this.controls.map(x => x.getRawValue());\n    }\n    getValidValue() {\n        return this.controls.map(x => x.getValidValue());\n    }\n    shouldValidate() {\n        if (this.parent) {\n            return this.parent.shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return (this.model.validationOption || { isOptional: false }).isOptional;\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    getControl() {\n        if (this.model.children) {\n            const group = new GeneratedFormGroup();\n            group.setConfig({\n                ...this.model,\n                instance: this.model.arrayType\n            });\n            return group;\n        }\n        const formControl = new GeneratedFormControl({\n            ...this.model,\n            type: this.model.arrayType.name\n        }, this.asyncValidators);\n        formControl.setAsyncControlValidators(this.model.asyncValidators);\n        return formControl;\n    }\n}\nclass GeneratedFormControl extends FormControl {\n    constructor(model, asyncValidators = []) {\n        super(model.defaultValue, model.validators);\n        this.model = model;\n        this.asyncValidators = asyncValidators;\n    }\n    getRawValue() {\n        switch (this.model.type) {\n            case \"Number\":\n                if (this.value === null || this.value === undefined) {\n                    return this.value;\n                }\n                if (this.model.validationOption && this.model.validationOption.ignoreZero && +this.value === 0) {\n                    return;\n                }\n                return +this.value;\n            case \"String\":\n                if (this.model.validationOption && this.model.validationOption.ignoreEmpty && this.value === \"\") {\n                    return;\n                }\n                return this.value;\n            default:\n                return this.value;\n        }\n    }\n    getValidValue() {\n        if (this.invalid) {\n            return undefined;\n        }\n        return this.getRawValue();\n    }\n    shouldValidate() {\n        if (this.parent) {\n            return this.parent.shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return !(this.model.validationOption || { isOptional: false }).isOptional;\n    }\n    setAsyncControlValidators(validators) {\n        if (validators && validators.length) {\n            this.setAsyncValidators(validators.map(x => this.customAsyncValidator.bind(this, x)));\n        }\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    customAsyncValidator(controlValidator, control) {\n        if (!this.asyncValidators) {\n            return of(null);\n        }\n        const validator = this.asyncValidators.find(x => controlValidator.name === x.name);\n        if (!validator) {\n            return of(null);\n        }\n        return validator.validate(control);\n    }\n}\n\nconst CONTROLS = \"__CONTROLS__\";\nconst CONTROL = \"__CONTROL[{name}]__\";\n\nclass NgxFormGeneratorScanner {\n    static getControls(model) {\n        const controls = Reflect.getMetadata(CONTROLS, model.prototype);\n        return controls.map(x => this.getControl(x, model));\n    }\n    static getControl(name, model) {\n        return Reflect.getMetadata(CONTROL.replace(\"{name}\", name), model.prototype);\n    }\n}\n\nfunction ngxFormGeneratorFactory(provider) {\n    return (asyncValidators) => {\n        const group = new GeneratedFormGroup(asyncValidators);\n        group.setConfig({\n            instance: provider,\n            children: NgxFormGeneratorScanner.getControls(provider)\n        });\n        return group;\n    };\n}\n\n// @dynamic\nclass ArrayHandler {\n    static setup(type) {\n        return (target, propertyKey) => {\n            let array = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const children = Reflect.getMetadata(CONTROLS, type.prototype);\n            if (!array) {\n                const controls = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            array = {\n                name: propertyKey,\n                key: propertyKey,\n                formElementType: \"array\",\n                type: \"Array\",\n                validators: array?.validators ?? [],\n                arrayType: type,\n                children: children ? children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), type.prototype)) : null\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), array, target);\n        };\n    }\n}\n\nfunction Array$1(type) {\n    return ArrayHandler.setup(type);\n}\n\n// @dynamic\nclass ControlHandler {\n    static setup(config = {}) {\n        return (target, propertyKey) => {\n            let control = this.getControl(target, propertyKey);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            control = {\n                ...control,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                type: controlType.name,\n                defaultValue: config.defaultValue\n            };\n            this.saveControl(control, target, propertyKey);\n        };\n    }\n    static getControl(target, propertyKey) {\n        let control = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n        if (!control) {\n            control = {\n                name: null,\n                key: null,\n                formElementType: \"control\",\n                type: null,\n                validators: [],\n                asyncValidators: []\n            };\n            const controls = Reflect.getMetadata(CONTROLS, target) || [];\n            controls.push(propertyKey);\n            Reflect.defineMetadata(CONTROLS, controls, target);\n        }\n        return control;\n    }\n    static saveControl(control, target, propertyKey) {\n        Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), control, target);\n    }\n}\n\nfunction Control(config) {\n    return ControlHandler.setup(config);\n}\n\n// @dynamic\nclass GroupHandler {\n    static setup(config = {}) {\n        return (target, propertyKey) => {\n            let group = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            const children = Reflect.getMetadata(CONTROLS, controlType.prototype);\n            if (!group) {\n                const controls = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            group = {\n                ...group,\n                instance: controlType,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                formElementType: \"group\",\n                type: controlType.name,\n                defaultValue: config.defaultValue,\n                children: children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), controlType.prototype))\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), group, target);\n        };\n    }\n}\n\nfunction Group(config) {\n    return GroupHandler.setup(config);\n}\n\nfunction validationWrapper(fn) {\n    return (control) => {\n        if (control.shouldValidate()) {\n            return fn(control);\n        }\n        return null;\n    };\n}\n\n// @dynamic\nclass ValidatorsHandler {\n    static setup(fn) {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validators.push(validationWrapper(fn));\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static setupAsync(validator) {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.asyncValidators.push(validator);\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static isOptional() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                isOptional: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static ignoreZero() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreZero: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static ignoreEmpty() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreEmpty: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n}\n\nfunction arrayMaxLength(max, checkNull = true) {\n    return (control) => {\n        if (control.value instanceof Array) {\n            if (control.value.length <= max) {\n                return null;\n            }\n            return {\n                arrayMaxLength: true\n            };\n        }\n        if (!control.value && checkNull) {\n            return {\n                arrayMaxLength: true\n            };\n        }\n        return null;\n    };\n}\n\nfunction arrayMinLength(min, checkNull = true) {\n    return (control) => {\n        if (control.value instanceof Array) {\n            if (control.value.length >= min) {\n                return null;\n            }\n            return {\n                arrayMinLength: true\n            };\n        }\n        if (!control.value && checkNull) {\n            return {\n                arrayMinLength: true\n            };\n        }\n        return null;\n    };\n}\n\nfunction customPattern(regex, error) {\n    return (control) => {\n        if (!control.value) {\n            // if control is empty return no error\n            return null;\n        }\n        // test the value of the control against the regexp supplied\n        const valid = regex.test(control.value);\n        // if true, return no error (no error), else return error passed in the second parameter\n        return valid ? null : error;\n    };\n}\n\nfunction matches(otherControlName) {\n    return (control) => {\n        if (!control.parent || !control.parent.controls[otherControlName]) {\n            return null;\n        }\n        const error = `${otherControlName}_mismatch`;\n        return control.parent.controls[otherControlName].value === control.value ? null : { [error]: true };\n    };\n}\n\nfunction valueIs(expected) {\n    return (control) => {\n        const actual = control.value;\n        if (actual === null || actual === undefined) {\n            return null; // Don't validate null values to allow optional controls.\n        }\n        return actual !== expected ? { valueIs: { actual, expected } } : null;\n    };\n}\n\nclass AsyncValidator {\n}\n\nfunction ArrayMaxLength(max, checkNull = true) {\n    return ValidatorsHandler.setup(arrayMaxLength(max, checkNull));\n}\n\nfunction ArrayMinLength(min, checkNull = true) {\n    return ValidatorsHandler.setup(arrayMinLength(min, checkNull));\n}\n\nfunction CustomPattern(regex, error) {\n    return ValidatorsHandler.setup(customPattern(regex, error));\n}\n\nfunction Email() {\n    return ValidatorsHandler.setup(Validators.email);\n}\n\nfunction IgnoreEmpty() {\n    return ValidatorsHandler.ignoreEmpty();\n}\n\nfunction IgnoreZero() {\n    return ValidatorsHandler.ignoreZero();\n}\n\nfunction MatchesControl(controlName) {\n    return ValidatorsHandler.setup(matches(controlName));\n}\n\nfunction MatchesPattern(pattern) {\n    return ValidatorsHandler.setup(Validators.pattern(pattern));\n}\n\nfunction Max(max) {\n    return ValidatorsHandler.setup(Validators.max(max));\n}\n\nfunction MaxLength(max) {\n    return ValidatorsHandler.setup(Validators.maxLength(max));\n}\n\nfunction Min(min) {\n    return ValidatorsHandler.setup(Validators.min(min));\n}\n\nfunction MinLength(min) {\n    return ValidatorsHandler.setup(Validators.minLength(min));\n}\n\nfunction Optional() {\n    return ValidatorsHandler.isOptional();\n}\n\nfunction Required() {\n    return ValidatorsHandler.setup(Validators.required);\n}\n\nfunction RequiredTrue() {\n    return ValidatorsHandler.setup(Validators.requiredTrue);\n}\n\nfunction ValueIs(expected) {\n    return ValidatorsHandler.setup(valueIs(expected));\n}\n\nfunction registerAsyncValidatorDecorator(validator) {\n    return ValidatorsHandler.setupAsync(validator);\n}\n\n/*\n * Public API Surface of form-generator\n */\n// @dynamic\nclass NgxFormGeneratorModule {\n    static forRoot(options = {}) {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: options?.asyncValidators?.map((provider) => {\n                const p = {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    multi: true\n                };\n                if (provider.useFactory) {\n                    p.useFactory = provider.useFactory;\n                    p.deps = provider.deps;\n                }\n                else {\n                    p.useClass = provider.useClass ?? provider;\n                }\n                return p;\n            }) ?? [\n                {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    useValue: []\n                }\n            ]\n        };\n    }\n    static forFeature(providers) {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: providers.map(provider => ({\n                provide: provider.provide || GeneratedFormGroup,\n                useFactory: ngxFormGeneratorFactory(provider.useValue || provider)\n            }))\n        };\n    }\n}\nNgxFormGeneratorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxFormGeneratorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, imports: [FormsModule, ReactiveFormsModule] });\nNgxFormGeneratorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, imports: [[FormsModule, ReactiveFormsModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [FormsModule, ReactiveFormsModule]\n                }]\n        }] });\n// @dynamic\nclass NgxFormGeneratorProvider {\n    static forFeature(providers) {\n        return providers.map(provider => ({\n            provide: provider.provide || GeneratedFormGroup,\n            useFactory: ngxFormGeneratorFactory(provider.useValue || provider),\n            deps: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n        }));\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Array$1 as Array, ArrayMaxLength, ArrayMinLength, AsyncValidator, Control, CustomPattern, Email, GeneratedFormArray, GeneratedFormControl, GeneratedFormGroup, Group, IgnoreEmpty, IgnoreZero, MatchesControl, MatchesPattern, Max, MaxLength, Min, MinLength, NGX_FORM_GENERATOR_ASYNC_VALIDATORS, NgxFormGeneratorModule, NgxFormGeneratorProvider, Optional, Required, RequiredTrue, ValidatorsHandler, ValueIs, arrayMaxLength, arrayMinLength, customPattern, matches, ngxFormGeneratorFactory, registerAsyncValidatorDecorator, valueIs };\n//# sourceMappingURL=recursyve-ngx-form-generator.mjs.map\n","map":{"version":3,"file":"recursyve-ngx-form-generator.mjs","sources":["../../../projects/form-generator/src/lib/validators/constant.ts","../../../projects/form-generator/src/lib/forms/generated-form.ts","../../../projects/form-generator/src/lib/constant.ts","../../../projects/form-generator/src/lib/ngx-form-generator.scanner.ts","../../../projects/form-generator/src/lib/ngx-form-generator.factory.ts","../../../projects/form-generator/src/lib/handlers/array.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/array.decorator.ts","../../../projects/form-generator/src/lib/handlers/control.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/control.decorator.ts","../../../projects/form-generator/src/lib/handlers/group.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/group.decorator.ts","../../../projects/form-generator/src/lib/validators/validator-wrapper.ts","../../../projects/form-generator/src/lib/handlers/validators.handler.ts","../../../projects/form-generator/src/lib/validators/array-max-length.validator.ts","../../../projects/form-generator/src/lib/validators/array-min-length.validator.ts","../../../projects/form-generator/src/lib/validators/custom-pattern.validator.ts","../../../projects/form-generator/src/lib/validators/matches-control.validator.ts","../../../projects/form-generator/src/lib/validators/value-is.validator.ts","../../../projects/form-generator/src/lib/validators/async.validator.ts","../../../projects/form-generator/src/lib/decorators/validators/array-max-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/array-min-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/custom-pattern.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/email.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/ignore-empty.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/ignore-zero.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/matches-control.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/matches-pattern.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/max.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/max-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/min.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/min-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/optional.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/required.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/required-true.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/value-is.decorator.ts","../../../projects/form-generator/src/lib/decorators/register-decorator.ts","../../../projects/form-generator/src/public-api.ts","../../../projects/form-generator/src/recursyve-ngx-form-generator.ts"],"sourcesContent":["import { InjectionToken } from \"@angular/core\";\n\nexport const NGX_FORM_GENERATOR_ASYNC_VALIDATORS = new InjectionToken(\"NGX_FORM_GENERATOR_ASYNC_VALIDATORS\");\n","import { EventEmitter, Inject, Injectable, Optional } from \"@angular/core\";\nimport { AbstractControl, FormArray, FormControl, FormGroup } from \"@angular/forms\";\nimport { of } from \"rxjs\";\nimport { ArrayModel } from \"../models/array.model\";\nimport { ControlAsyncValidators, ControlModel } from \"../models/control.model\";\nimport { GroupModel } from \"../models/group.model\";\nimport { AsyncValidator } from \"../validators/async.validator\";\nimport { NGX_FORM_GENERATOR_ASYNC_VALIDATORS } from \"../validators/constant\";\nimport { GeneratedControl } from \"./generated-control\";\n\n@Injectable()\nexport class GeneratedFormGroup<T> extends FormGroup implements GeneratedControl {\n    // tslint:disable-next-line:variable-name\n    private _models: (ControlModel | GroupModel | ArrayModel)[];\n    private config: GroupModel;\n\n    public controls: { [key: string]: GeneratedControl };\n\n    constructor(\n        @Optional()\n        @Inject(NGX_FORM_GENERATOR_ASYNC_VALIDATORS)\n        private asyncValidators: AsyncValidator[] = []\n    ) {\n        super({});\n    }\n\n    public setConfig(config: GroupModel) {\n        this.config = config;\n        this._models = config.children;\n        this.setValidators(config.validators);\n        this.generateControls();\n    }\n\n    public patchValue(value: T, options: { onlySelf?: boolean; emitEvent?: boolean } = {}): void {\n        if (!value) {\n            return;\n        }\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const model = this._models.find(x => x.name === key);\n            this.controls[key].patchValue(value[model.key], { onlySelf: true, emitEvent: options.emitEvent });\n        }\n\n        this.updateValueAndValidity(options);\n    }\n\n    public getRawValue(): T {\n        const rawValue = new this.config.instance();\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            rawValue[model.key] = control.getRawValue();\n        }\n\n        return rawValue;\n    }\n\n    public getValidValue(): T {\n        const validValue = new this.config.instance();\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            validValue[model.key] = control.getValidValue();\n        }\n\n        return validValue;\n    }\n\n    public shouldValidate(): boolean {\n        let parentValidation = true;\n        if (this.parent) {\n            parentValidation = (this.parent as any as GeneratedControl).shouldValidate();\n        }\n        if (!this.config) {\n            return true;\n        }\n        return (this.config.validationOption || { isOptional: false }).isOptional ? false : parentValidation;\n    }\n\n    public copy(): GeneratedFormGroup<T> {\n        const group = new GeneratedFormGroup<T>();\n        group.setConfig(this.config);\n        return group;\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private generateControls() {\n        for (const control of this._models) {\n            let formControl: AbstractControl;\n            if (control.formElementType === \"array\") {\n                formControl = new GeneratedFormArray(control as ArrayModel, this.asyncValidators);\n            } else if (control.formElementType === \"group\") {\n                formControl = new GeneratedFormGroup(this.asyncValidators);\n                (formControl as GeneratedFormGroup<T>).setConfig(control as GroupModel);\n            } else {\n                formControl = new GeneratedFormControl(control, this.asyncValidators);\n                (formControl as GeneratedFormControl<any>).setAsyncControlValidators((control as ControlModel).asyncValidators);\n            }\n            super.addControl(control.name, formControl);\n        }\n    }\n}\n\nexport class GeneratedFormArray<T> extends FormArray implements GeneratedControl {\n    public controls: GeneratedControl[];\n\n    constructor(private model: ArrayModel, private asyncValidators: AsyncValidator[] = []) {\n        super(model.defaultValue ?? [], model.validators);\n    }\n\n    public push(value: unknown | T): void {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.push(control);\n    }\n\n    public insert(index: number, value: unknown | T): void {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.insert(index, control);\n    }\n\n    public at(index: number): GeneratedControl {\n        return super.at(index) as GeneratedControl;\n    }\n\n    public patchValue(value: T[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}): void {\n        if (!value) {\n            return;\n        }\n\n        let i = 0;\n        for (const data of value) {\n            if (i >= this.controls.length) {\n                this.push(null);\n            }\n            this.at(i).patchValue(data, { onlySelf: true, emitEvent: options.emitEvent });\n            ++i;\n        }\n\n        this.updateValueAndValidity(options);\n    }\n\n    public getRawValue(): T[] {\n        return this.controls.map(x => x.getRawValue());\n    }\n\n    public getValidValue(): T[] {\n        return this.controls.map(x => x.getValidValue());\n    }\n\n    public shouldValidate(): boolean {\n        if (this.parent) {\n            return (this.parent as any as GeneratedControl).shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return (this.model.validationOption || { isOptional: false }).isOptional;\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private getControl(): AbstractControl {\n        if (this.model.children) {\n            const group = new GeneratedFormGroup();\n            group.setConfig({\n                ...this.model,\n                instance: this.model.arrayType\n            });\n            return group;\n        }\n\n        const formControl = new GeneratedFormControl({\n            ...this.model,\n            type: (this.model.arrayType as () => void).name\n        }, this.asyncValidators);\n        formControl.setAsyncControlValidators((this.model as ControlModel).asyncValidators);\n        return formControl;\n    }\n}\n\nexport class GeneratedFormControl<T> extends FormControl implements GeneratedControl {\n    constructor(private model: ControlModel, private asyncValidators: AsyncValidator[] = []) {\n        super(model.defaultValue, model.validators);\n    }\n\n    public getRawValue(): T {\n        switch (this.model.type) {\n            case \"Number\":\n                if (this.value === null || this.value === undefined) {\n                    return this.value;\n                }\n\n                if (this.model.validationOption && this.model.validationOption.ignoreZero && +this.value === 0) {\n                    return;\n                }\n\n                return +this.value as any;\n            case \"String\":\n                if (this.model.validationOption && this.model.validationOption.ignoreEmpty && this.value === \"\") {\n                    return;\n                }\n\n                return this.value;\n            default:\n                return this.value;\n        }\n    }\n\n    public getValidValue(): T {\n        if (this.invalid) {\n            return undefined;\n        }\n\n        return this.getRawValue();\n    }\n\n    public shouldValidate(): boolean {\n        if (this.parent) {\n            return (this.parent as any as GeneratedControl).shouldValidate();\n        }\n\n        if (!this.model) {\n            return true;\n        }\n        return !(this.model.validationOption || { isOptional: false }).isOptional;\n    }\n\n    public setAsyncControlValidators(validators: ControlAsyncValidators[]): void {\n        if (validators && validators.length) {\n            this.setAsyncValidators(validators.map(x => this.customAsyncValidator.bind(this, x)));\n        }\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private customAsyncValidator(controlValidator: ControlAsyncValidators, control: AbstractControl) {\n        if (!this.asyncValidators) {\n            return of(null);\n        }\n\n        const validator = this.asyncValidators.find(x => controlValidator.name === x.name);\n        if (!validator) {\n            return of(null);\n        }\n\n        return validator.validate(control);\n    }\n}\n","export const CONTROLS = \"__CONTROLS__\";\nexport const CONTROL = \"__CONTROL[{name}]__\";\n","import \"reflect-metadata\";\nimport { ControlModel } from \"./models/control.model\";\nimport { CONTROL, CONTROLS } from \"./constant\";\n\nexport class NgxFormGeneratorScanner {\n    public static getControls(model: any): ControlModel[] {\n        const controls = Reflect.getMetadata(CONTROLS, model.prototype) as string[];\n        return controls.map(x => this.getControl(x, model));\n    }\n\n    public static getControl(name: string, model: any): ControlModel {\n        return Reflect.getMetadata(CONTROL.replace(\"{name}\", name), model.prototype);\n    }\n}\n","import { GeneratedFormGroup } from \"./forms\";\nimport { GroupModel } from \"./models/group.model\";\nimport { NgxFormGeneratorScanner } from \"./ngx-form-generator.scanner\";\nimport { AsyncValidator } from \"./validators/async.validator\";\n\nexport function ngxFormGeneratorFactory(provider: any) {\n    return (asyncValidators: AsyncValidator[]) => {\n        const group = new GeneratedFormGroup(asyncValidators);\n        group.setConfig({\n            instance: provider,\n            children: NgxFormGeneratorScanner.getControls(provider)\n        } as GroupModel);\n        return group;\n    };\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { ArrayModel } from \"../models/array.model\";\n\n// @dynamic\nexport class ArrayHandler {\n    public static setup(type: () => void): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let array: ArrayModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const children = Reflect.getMetadata(CONTROLS, type.prototype) as string[];\n            if (!array) {\n                const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            array = {\n                name: propertyKey,\n                key: propertyKey,\n                formElementType: \"array\",\n                type: \"Array\",\n                validators: array?.validators ?? [],\n                arrayType: type,\n                children: children ? children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), type.prototype)) : null\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), array, target);\n        };\n    }\n}\n","import { ArrayHandler } from \"../../handlers/array.handler\";\n\nexport function Array(type: object): PropertyDecorator {\n    return ArrayHandler.setup(type as () => void);\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { ControlConfigModel, ControlModel } from \"../models/control.model\";\n\n// @dynamic\nexport class ControlHandler {\n    public static setup(config: ControlConfigModel = {}): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let control: ControlModel = this.getControl(target, propertyKey);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            control = {\n                ...control,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                type: controlType.name,\n                defaultValue: config.defaultValue\n            };\n            this.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static getControl(target: object, propertyKey: string): ControlModel {\n        let control: ControlModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n        if (!control) {\n            control = {\n                name: null,\n                key: null,\n                formElementType: \"control\",\n                type: null,\n                validators: [],\n                asyncValidators: []\n            };\n            const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n            controls.push(propertyKey);\n            Reflect.defineMetadata(CONTROLS, controls, target);\n        }\n\n        return control;\n    }\n\n    public static saveControl(control: ControlModel, target: object, propertyKey: string) {\n        Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), control, target);\n    }\n}\n","import { ControlHandler,  } from \"../../handlers/control.handler\";\nimport { ControlConfigModel } from \"../../models/control.model\";\n\nexport function Control(config?: ControlConfigModel): PropertyDecorator {\n    return ControlHandler.setup(config);\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { GroupConfigModel, GroupModel } from \"../models/group.model\";\n\n// @dynamic\nexport class GroupHandler {\n    public static setup(config: GroupConfigModel = {}): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let group: GroupModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            const children = Reflect.getMetadata(CONTROLS, controlType.prototype) as string[];\n            if (!group) {\n                const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            group = {\n                ...group,\n                instance: controlType,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                formElementType: \"group\",\n                type: controlType.name,\n                defaultValue: config.defaultValue,\n                children: children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), controlType.prototype))\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), group, target);\n        };\n    }\n}\n","import { GroupHandler } from \"../../handlers/group.handler\";\nimport { GroupConfigModel } from \"../../models/group.model\";\n\nexport function Group(config?: GroupConfigModel): PropertyDecorator {\n    return GroupHandler.setup(config);\n}\n","import { ValidationErrors, ValidatorFn } from \"@angular/forms\";\nimport { GeneratedControl } from \"../forms\";\n\nexport function validationWrapper(fn: ValidatorFn): ValidatorFn {\n    return (control: GeneratedControl): ValidationErrors | null => {\n        if (control.shouldValidate()) {\n            return fn(control);\n        }\n\n        return null;\n    };\n}\n","import \"reflect-metadata\";\nimport { ValidatorFn } from \"@angular/forms\";\nimport { ControlAsyncValidators, ControlModel } from \"../models/control.model\";\nimport { validationWrapper } from \"../validators/validator-wrapper\";\nimport { ControlHandler } from \"./control.handler\";\n\n// @dynamic\nexport class ValidatorsHandler {\n    public static setup(fn: ValidatorFn) {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validators.push(validationWrapper(fn));\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static setupAsync(validator: ControlAsyncValidators) {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.asyncValidators.push(validator);\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static isOptional() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                isOptional: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static ignoreZero() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreZero: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static ignoreEmpty() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreEmpty: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function arrayMaxLength(max: number, checkNull = true): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (control.value instanceof Array) {\n            if (control.value.length <= max) {\n                return null;\n            }\n\n            return {\n                arrayMaxLength: true\n            };\n        }\n\n        if (!control.value && checkNull) {\n            return {\n                arrayMaxLength: true\n            };\n        }\n\n        return null;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function arrayMinLength(min: number, checkNull = true): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (control.value instanceof Array) {\n            if (control.value.length >= min) {\n                return null;\n            }\n\n            return {\n                arrayMinLength: true\n            };\n        }\n\n        if (!control.value && checkNull) {\n            return {\n                arrayMinLength: true\n            };\n        }\n\n        return null;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function customPattern(regex: RegExp, error: ValidationErrors): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (!control.value) {\n            // if control is empty return no error\n            return null;\n        }\n\n        // test the value of the control against the regexp supplied\n        const valid = regex.test(control.value);\n\n        // if true, return no error (no error), else return error passed in the second parameter\n        return valid ? null : error;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function matches(otherControlName: string): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (!control.parent || !control.parent.controls[otherControlName]) {\n            return null;\n        }\n        const error = `${otherControlName}_mismatch`;\n        return control.parent.controls[otherControlName].value === control.value ? null : { [error]: true };\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function valueIs(expected: any): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        const actual = control.value;\n        if (actual === null || actual === undefined) {\n            return null; // Don't validate null values to allow optional controls.\n        }\n\n        return actual !== expected ? { valueIs: { actual, expected } } : null;\n    };\n}\n","import { AbstractControl, ValidationErrors } from \"@angular/forms\";\nimport { Observable } from \"rxjs\";\n\nexport abstract class AsyncValidator {\n    public abstract name: string;\n    public abstract validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ArrayMaxLength(max: number, checkNull = true): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.arrayMaxLength(max, checkNull));\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ArrayMinLength(min: number, checkNull = true): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.arrayMinLength(min, checkNull));\n}\n","import { ValidationErrors } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function CustomPattern(regex: RegExp, error: ValidationErrors): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.customPattern(regex, error));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Email(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.email);\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function IgnoreEmpty(): PropertyDecorator {\n    return ValidatorsHandler.ignoreEmpty();\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function IgnoreZero(): PropertyDecorator {\n    return ValidatorsHandler.ignoreZero();\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function MatchesControl(controlName: string): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.matches(controlName));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MatchesPattern(pattern: string | RegExp): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.pattern(pattern));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Max(max: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.max(max));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MaxLength(max: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.maxLength(max));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Min(min: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.min(min));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MinLength(min: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.minLength(min));\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Optional(): PropertyDecorator {\n    return ValidatorsHandler.isOptional();\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Required(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.required);\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function RequiredTrue(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.requiredTrue);\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ValueIs(expected: any): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.valueIs(expected));\n}\n","import { ValidatorsHandler } from \"../handlers/validators.handler\";\nimport { ControlAsyncValidators } from \"../models/control.model\";\n\nexport function registerAsyncValidatorDecorator(validator: ControlAsyncValidators) {\n    return ValidatorsHandler.setupAsync(validator);\n}\n","/*\n * Public API Surface of form-generator\n */\n\nimport { ClassProvider, FactoryProvider, ModuleWithProviders, NgModule, Provider, ValueProvider } from \"@angular/core\";\nimport { FormsModule, ReactiveFormsModule } from \"@angular/forms\";\nimport { GeneratedFormGroup } from \"./lib/forms\";\nimport { ngxFormGeneratorFactory } from \"./lib/ngx-form-generator.factory\";\nimport { NGX_FORM_GENERATOR_ASYNC_VALIDATORS } from \"./lib/validators/constant\";\n\nexport interface NgxFormGeneratorOptions {\n    asyncValidators?: Provider[];\n}\n\n// @dynamic\n@NgModule({\n    imports: [FormsModule, ReactiveFormsModule]\n})\nexport class NgxFormGeneratorModule {\n    public static forRoot(options: NgxFormGeneratorOptions = {}): ModuleWithProviders<NgxFormGeneratorModule> {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: options?.asyncValidators?.map((provider) => {\n                const p = {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    multi: true\n                } as Provider;\n                if ((provider as FactoryProvider).useFactory) {\n                    (p as FactoryProvider).useFactory = (provider as FactoryProvider).useFactory;\n                    (p as FactoryProvider).deps = (provider as FactoryProvider).deps;\n                } else {\n                    (p as ClassProvider).useClass = (provider as ClassProvider).useClass ?? provider as any;\n                }\n                return p;\n            }) ?? [\n                {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    useValue: []\n                }\n            ]\n        };\n    }\n\n    public static forFeature(providers: Provider[]): ModuleWithProviders<NgxFormGeneratorModule> {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: providers.map(provider => ({\n                provide: (provider as ValueProvider).provide || GeneratedFormGroup,\n                useFactory: ngxFormGeneratorFactory((provider as ValueProvider).useValue || provider)\n            }))\n        };\n    }\n}\n\n// @dynamic\nexport class NgxFormGeneratorProvider {\n    public static forFeature(providers: Provider[]): Provider[] {\n        return providers.map(provider => ({\n            provide: (provider as ValueProvider).provide || GeneratedFormGroup,\n            useFactory: ngxFormGeneratorFactory((provider as ValueProvider).useValue || provider),\n            deps: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n        }));\n    }\n}\n\nexport * from \"./lib/decorators\";\nexport * from \"./lib/forms\";\nexport * from \"./lib/validators\";\nexport * from \"./lib/ngx-form-generator.factory\";\nexport * from \"./lib/handlers/validators.handler\";\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["Optional","Array","validators.arrayMaxLength","validators.arrayMinLength","validators.customPattern","validators.matches","validators.valueIs"],"mappings":"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"}},"fesm2015":{"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional as Optional$1, Inject, NgModule } from '@angular/core';\nimport { FormGroup, FormArray, FormControl, Validators, FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { of } from 'rxjs';\nimport 'reflect-metadata';\n\nconst NGX_FORM_GENERATOR_ASYNC_VALIDATORS = new InjectionToken(\"NGX_FORM_GENERATOR_ASYNC_VALIDATORS\");\n\nclass GeneratedFormGroup extends FormGroup {\n    constructor(asyncValidators = []) {\n        super({});\n        this.asyncValidators = asyncValidators;\n    }\n    setConfig(config) {\n        this.config = config;\n        this._models = config.children;\n        this.setValidators(config.validators);\n        this.generateControls();\n    }\n    patchValue(value, options = {}) {\n        if (!value) {\n            return;\n        }\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const model = this._models.find(x => x.name === key);\n            this.controls[key].patchValue(value[model.key], { onlySelf: true, emitEvent: options.emitEvent });\n        }\n        this.updateValueAndValidity(options);\n    }\n    getRawValue() {\n        const rawValue = new this.config.instance();\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            rawValue[model.key] = control.getRawValue();\n        }\n        return rawValue;\n    }\n    getValidValue() {\n        const validValue = new this.config.instance();\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            validValue[model.key] = control.getValidValue();\n        }\n        return validValue;\n    }\n    shouldValidate() {\n        let parentValidation = true;\n        if (this.parent) {\n            parentValidation = this.parent.shouldValidate();\n        }\n        if (!this.config) {\n            return true;\n        }\n        return (this.config.validationOption || { isOptional: false }).isOptional ? false : parentValidation;\n    }\n    copy() {\n        const group = new GeneratedFormGroup();\n        group.setConfig(this.config);\n        return group;\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    generateControls() {\n        for (const control of this._models) {\n            let formControl;\n            if (control.formElementType === \"array\") {\n                formControl = new GeneratedFormArray(control, this.asyncValidators);\n            }\n            else if (control.formElementType === \"group\") {\n                formControl = new GeneratedFormGroup(this.asyncValidators);\n                formControl.setConfig(control);\n            }\n            else {\n                formControl = new GeneratedFormControl(control, this.asyncValidators);\n                formControl.setAsyncControlValidators(control.asyncValidators);\n            }\n            super.addControl(control.name, formControl);\n        }\n    }\n}\nGeneratedFormGroup.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup, deps: [{ token: NGX_FORM_GENERATOR_ASYNC_VALIDATORS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\nGeneratedFormGroup.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: GeneratedFormGroup, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Optional$1\n                    }, {\n                        type: Inject,\n                        args: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n                    }] }];\n    } });\nclass GeneratedFormArray extends FormArray {\n    constructor(model, asyncValidators = []) {\n        var _a;\n        super((_a = model.defaultValue) !== null && _a !== void 0 ? _a : [], model.validators);\n        this.model = model;\n        this.asyncValidators = asyncValidators;\n    }\n    push(value) {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.push(control);\n    }\n    insert(index, value) {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.insert(index, control);\n    }\n    at(index) {\n        return super.at(index);\n    }\n    patchValue(value, options = {}) {\n        if (!value) {\n            return;\n        }\n        let i = 0;\n        for (const data of value) {\n            if (i >= this.controls.length) {\n                this.push(null);\n            }\n            this.at(i).patchValue(data, { onlySelf: true, emitEvent: options.emitEvent });\n            ++i;\n        }\n        this.updateValueAndValidity(options);\n    }\n    getRawValue() {\n        return this.controls.map(x => x.getRawValue());\n    }\n    getValidValue() {\n        return this.controls.map(x => x.getValidValue());\n    }\n    shouldValidate() {\n        if (this.parent) {\n            return this.parent.shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return (this.model.validationOption || { isOptional: false }).isOptional;\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    getControl() {\n        if (this.model.children) {\n            const group = new GeneratedFormGroup();\n            group.setConfig(Object.assign(Object.assign({}, this.model), { instance: this.model.arrayType }));\n            return group;\n        }\n        const formControl = new GeneratedFormControl(Object.assign(Object.assign({}, this.model), { type: this.model.arrayType.name }), this.asyncValidators);\n        formControl.setAsyncControlValidators(this.model.asyncValidators);\n        return formControl;\n    }\n}\nclass GeneratedFormControl extends FormControl {\n    constructor(model, asyncValidators = []) {\n        super(model.defaultValue, model.validators);\n        this.model = model;\n        this.asyncValidators = asyncValidators;\n    }\n    getRawValue() {\n        switch (this.model.type) {\n            case \"Number\":\n                if (this.value === null || this.value === undefined) {\n                    return this.value;\n                }\n                if (this.model.validationOption && this.model.validationOption.ignoreZero && +this.value === 0) {\n                    return;\n                }\n                return +this.value;\n            case \"String\":\n                if (this.model.validationOption && this.model.validationOption.ignoreEmpty && this.value === \"\") {\n                    return;\n                }\n                return this.value;\n            default:\n                return this.value;\n        }\n    }\n    getValidValue() {\n        if (this.invalid) {\n            return undefined;\n        }\n        return this.getRawValue();\n    }\n    shouldValidate() {\n        if (this.parent) {\n            return this.parent.shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return !(this.model.validationOption || { isOptional: false }).isOptional;\n    }\n    setAsyncControlValidators(validators) {\n        if (validators && validators.length) {\n            this.setAsyncValidators(validators.map(x => this.customAsyncValidator.bind(this, x)));\n        }\n    }\n    markAllAsTouched() {\n        super.markAllAsTouched();\n        this.statusChanges.emit(this.status);\n    }\n    customAsyncValidator(controlValidator, control) {\n        if (!this.asyncValidators) {\n            return of(null);\n        }\n        const validator = this.asyncValidators.find(x => controlValidator.name === x.name);\n        if (!validator) {\n            return of(null);\n        }\n        return validator.validate(control);\n    }\n}\n\nconst CONTROLS = \"__CONTROLS__\";\nconst CONTROL = \"__CONTROL[{name}]__\";\n\nclass NgxFormGeneratorScanner {\n    static getControls(model) {\n        const controls = Reflect.getMetadata(CONTROLS, model.prototype);\n        return controls.map(x => this.getControl(x, model));\n    }\n    static getControl(name, model) {\n        return Reflect.getMetadata(CONTROL.replace(\"{name}\", name), model.prototype);\n    }\n}\n\nfunction ngxFormGeneratorFactory(provider) {\n    return (asyncValidators) => {\n        const group = new GeneratedFormGroup(asyncValidators);\n        group.setConfig({\n            instance: provider,\n            children: NgxFormGeneratorScanner.getControls(provider)\n        });\n        return group;\n    };\n}\n\n// @dynamic\nclass ArrayHandler {\n    static setup(type) {\n        return (target, propertyKey) => {\n            var _a;\n            let array = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const children = Reflect.getMetadata(CONTROLS, type.prototype);\n            if (!array) {\n                const controls = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            array = {\n                name: propertyKey,\n                key: propertyKey,\n                formElementType: \"array\",\n                type: \"Array\",\n                validators: (_a = array === null || array === void 0 ? void 0 : array.validators) !== null && _a !== void 0 ? _a : [],\n                arrayType: type,\n                children: children ? children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), type.prototype)) : null\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), array, target);\n        };\n    }\n}\n\nfunction Array$1(type) {\n    return ArrayHandler.setup(type);\n}\n\n// @dynamic\nclass ControlHandler {\n    static setup(config = {}) {\n        return (target, propertyKey) => {\n            let control = this.getControl(target, propertyKey);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            control = Object.assign(Object.assign({}, control), { name: config.name || propertyKey, key: propertyKey, type: controlType.name, defaultValue: config.defaultValue });\n            this.saveControl(control, target, propertyKey);\n        };\n    }\n    static getControl(target, propertyKey) {\n        let control = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n        if (!control) {\n            control = {\n                name: null,\n                key: null,\n                formElementType: \"control\",\n                type: null,\n                validators: [],\n                asyncValidators: []\n            };\n            const controls = Reflect.getMetadata(CONTROLS, target) || [];\n            controls.push(propertyKey);\n            Reflect.defineMetadata(CONTROLS, controls, target);\n        }\n        return control;\n    }\n    static saveControl(control, target, propertyKey) {\n        Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), control, target);\n    }\n}\n\nfunction Control(config) {\n    return ControlHandler.setup(config);\n}\n\n// @dynamic\nclass GroupHandler {\n    static setup(config = {}) {\n        return (target, propertyKey) => {\n            let group = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            const children = Reflect.getMetadata(CONTROLS, controlType.prototype);\n            if (!group) {\n                const controls = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            group = Object.assign(Object.assign({}, group), { instance: controlType, name: config.name || propertyKey, key: propertyKey, formElementType: \"group\", type: controlType.name, defaultValue: config.defaultValue, children: children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), controlType.prototype)) });\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), group, target);\n        };\n    }\n}\n\nfunction Group(config) {\n    return GroupHandler.setup(config);\n}\n\nfunction validationWrapper(fn) {\n    return (control) => {\n        if (control.shouldValidate()) {\n            return fn(control);\n        }\n        return null;\n    };\n}\n\n// @dynamic\nclass ValidatorsHandler {\n    static setup(fn) {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validators.push(validationWrapper(fn));\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static setupAsync(validator) {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.asyncValidators.push(validator);\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static isOptional() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = Object.assign(Object.assign({}, (control.validationOption || {})), { isOptional: true });\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static ignoreZero() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = Object.assign(Object.assign({}, (control.validationOption || {})), { ignoreZero: true });\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n    static ignoreEmpty() {\n        return (target, propertyKey) => {\n            const control = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = Object.assign(Object.assign({}, (control.validationOption || {})), { ignoreEmpty: true });\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n}\n\nfunction arrayMaxLength(max, checkNull = true) {\n    return (control) => {\n        if (control.value instanceof Array) {\n            if (control.value.length <= max) {\n                return null;\n            }\n            return {\n                arrayMaxLength: true\n            };\n        }\n        if (!control.value && checkNull) {\n            return {\n                arrayMaxLength: true\n            };\n        }\n        return null;\n    };\n}\n\nfunction arrayMinLength(min, checkNull = true) {\n    return (control) => {\n        if (control.value instanceof Array) {\n            if (control.value.length >= min) {\n                return null;\n            }\n            return {\n                arrayMinLength: true\n            };\n        }\n        if (!control.value && checkNull) {\n            return {\n                arrayMinLength: true\n            };\n        }\n        return null;\n    };\n}\n\nfunction customPattern(regex, error) {\n    return (control) => {\n        if (!control.value) {\n            // if control is empty return no error\n            return null;\n        }\n        // test the value of the control against the regexp supplied\n        const valid = regex.test(control.value);\n        // if true, return no error (no error), else return error passed in the second parameter\n        return valid ? null : error;\n    };\n}\n\nfunction matches(otherControlName) {\n    return (control) => {\n        if (!control.parent || !control.parent.controls[otherControlName]) {\n            return null;\n        }\n        const error = `${otherControlName}_mismatch`;\n        return control.parent.controls[otherControlName].value === control.value ? null : { [error]: true };\n    };\n}\n\nfunction valueIs(expected) {\n    return (control) => {\n        const actual = control.value;\n        if (actual === null || actual === undefined) {\n            return null; // Don't validate null values to allow optional controls.\n        }\n        return actual !== expected ? { valueIs: { actual, expected } } : null;\n    };\n}\n\nclass AsyncValidator {\n}\n\nfunction ArrayMaxLength(max, checkNull = true) {\n    return ValidatorsHandler.setup(arrayMaxLength(max, checkNull));\n}\n\nfunction ArrayMinLength(min, checkNull = true) {\n    return ValidatorsHandler.setup(arrayMinLength(min, checkNull));\n}\n\nfunction CustomPattern(regex, error) {\n    return ValidatorsHandler.setup(customPattern(regex, error));\n}\n\nfunction Email() {\n    return ValidatorsHandler.setup(Validators.email);\n}\n\nfunction IgnoreEmpty() {\n    return ValidatorsHandler.ignoreEmpty();\n}\n\nfunction IgnoreZero() {\n    return ValidatorsHandler.ignoreZero();\n}\n\nfunction MatchesControl(controlName) {\n    return ValidatorsHandler.setup(matches(controlName));\n}\n\nfunction MatchesPattern(pattern) {\n    return ValidatorsHandler.setup(Validators.pattern(pattern));\n}\n\nfunction Max(max) {\n    return ValidatorsHandler.setup(Validators.max(max));\n}\n\nfunction MaxLength(max) {\n    return ValidatorsHandler.setup(Validators.maxLength(max));\n}\n\nfunction Min(min) {\n    return ValidatorsHandler.setup(Validators.min(min));\n}\n\nfunction MinLength(min) {\n    return ValidatorsHandler.setup(Validators.minLength(min));\n}\n\nfunction Optional() {\n    return ValidatorsHandler.isOptional();\n}\n\nfunction Required() {\n    return ValidatorsHandler.setup(Validators.required);\n}\n\nfunction RequiredTrue() {\n    return ValidatorsHandler.setup(Validators.requiredTrue);\n}\n\nfunction ValueIs(expected) {\n    return ValidatorsHandler.setup(valueIs(expected));\n}\n\nfunction registerAsyncValidatorDecorator(validator) {\n    return ValidatorsHandler.setupAsync(validator);\n}\n\n/*\n * Public API Surface of form-generator\n */\n// @dynamic\nclass NgxFormGeneratorModule {\n    static forRoot(options = {}) {\n        var _a, _b;\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: (_b = (_a = options === null || options === void 0 ? void 0 : options.asyncValidators) === null || _a === void 0 ? void 0 : _a.map((provider) => {\n                var _a;\n                const p = {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    multi: true\n                };\n                if (provider.useFactory) {\n                    p.useFactory = provider.useFactory;\n                    p.deps = provider.deps;\n                }\n                else {\n                    p.useClass = (_a = provider.useClass) !== null && _a !== void 0 ? _a : provider;\n                }\n                return p;\n            })) !== null && _b !== void 0 ? _b : [\n                {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    useValue: []\n                }\n            ]\n        };\n    }\n    static forFeature(providers) {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: providers.map(provider => ({\n                provide: provider.provide || GeneratedFormGroup,\n                useFactory: ngxFormGeneratorFactory(provider.useValue || provider)\n            }))\n        };\n    }\n}\nNgxFormGeneratorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxFormGeneratorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, imports: [FormsModule, ReactiveFormsModule] });\nNgxFormGeneratorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, imports: [[FormsModule, ReactiveFormsModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.3\", ngImport: i0, type: NgxFormGeneratorModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [FormsModule, ReactiveFormsModule]\n                }]\n        }] });\n// @dynamic\nclass NgxFormGeneratorProvider {\n    static forFeature(providers) {\n        return providers.map(provider => ({\n            provide: provider.provide || GeneratedFormGroup,\n            useFactory: ngxFormGeneratorFactory(provider.useValue || provider),\n            deps: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n        }));\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Array$1 as Array, ArrayMaxLength, ArrayMinLength, AsyncValidator, Control, CustomPattern, Email, GeneratedFormArray, GeneratedFormControl, GeneratedFormGroup, Group, IgnoreEmpty, IgnoreZero, MatchesControl, MatchesPattern, Max, MaxLength, Min, MinLength, NGX_FORM_GENERATOR_ASYNC_VALIDATORS, NgxFormGeneratorModule, NgxFormGeneratorProvider, Optional, Required, RequiredTrue, ValidatorsHandler, ValueIs, arrayMaxLength, arrayMinLength, customPattern, matches, ngxFormGeneratorFactory, registerAsyncValidatorDecorator, valueIs };\n//# sourceMappingURL=recursyve-ngx-form-generator.mjs.map\n","map":{"version":3,"file":"recursyve-ngx-form-generator.mjs","sources":["../../../projects/form-generator/src/lib/validators/constant.ts","../../../projects/form-generator/src/lib/forms/generated-form.ts","../../../projects/form-generator/src/lib/constant.ts","../../../projects/form-generator/src/lib/ngx-form-generator.scanner.ts","../../../projects/form-generator/src/lib/ngx-form-generator.factory.ts","../../../projects/form-generator/src/lib/handlers/array.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/array.decorator.ts","../../../projects/form-generator/src/lib/handlers/control.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/control.decorator.ts","../../../projects/form-generator/src/lib/handlers/group.handler.ts","../../../projects/form-generator/src/lib/decorators/controls/group.decorator.ts","../../../projects/form-generator/src/lib/validators/validator-wrapper.ts","../../../projects/form-generator/src/lib/handlers/validators.handler.ts","../../../projects/form-generator/src/lib/validators/array-max-length.validator.ts","../../../projects/form-generator/src/lib/validators/array-min-length.validator.ts","../../../projects/form-generator/src/lib/validators/custom-pattern.validator.ts","../../../projects/form-generator/src/lib/validators/matches-control.validator.ts","../../../projects/form-generator/src/lib/validators/value-is.validator.ts","../../../projects/form-generator/src/lib/validators/async.validator.ts","../../../projects/form-generator/src/lib/decorators/validators/array-max-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/array-min-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/custom-pattern.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/email.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/ignore-empty.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/ignore-zero.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/matches-control.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/matches-pattern.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/max.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/max-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/min.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/min-length.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/optional.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/required.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/required-true.decorator.ts","../../../projects/form-generator/src/lib/decorators/validators/value-is.decorator.ts","../../../projects/form-generator/src/lib/decorators/register-decorator.ts","../../../projects/form-generator/src/public-api.ts","../../../projects/form-generator/src/recursyve-ngx-form-generator.ts"],"sourcesContent":["import { InjectionToken } from \"@angular/core\";\n\nexport const NGX_FORM_GENERATOR_ASYNC_VALIDATORS = new InjectionToken(\"NGX_FORM_GENERATOR_ASYNC_VALIDATORS\");\n","import { EventEmitter, Inject, Injectable, Optional } from \"@angular/core\";\nimport { AbstractControl, FormArray, FormControl, FormGroup } from \"@angular/forms\";\nimport { of } from \"rxjs\";\nimport { ArrayModel } from \"../models/array.model\";\nimport { ControlAsyncValidators, ControlModel } from \"../models/control.model\";\nimport { GroupModel } from \"../models/group.model\";\nimport { AsyncValidator } from \"../validators/async.validator\";\nimport { NGX_FORM_GENERATOR_ASYNC_VALIDATORS } from \"../validators/constant\";\nimport { GeneratedControl } from \"./generated-control\";\n\n@Injectable()\nexport class GeneratedFormGroup<T> extends FormGroup implements GeneratedControl {\n    // tslint:disable-next-line:variable-name\n    private _models: (ControlModel | GroupModel | ArrayModel)[];\n    private config: GroupModel;\n\n    public controls: { [key: string]: GeneratedControl };\n\n    constructor(\n        @Optional()\n        @Inject(NGX_FORM_GENERATOR_ASYNC_VALIDATORS)\n        private asyncValidators: AsyncValidator[] = []\n    ) {\n        super({});\n    }\n\n    public setConfig(config: GroupModel) {\n        this.config = config;\n        this._models = config.children;\n        this.setValidators(config.validators);\n        this.generateControls();\n    }\n\n    public patchValue(value: T, options: { onlySelf?: boolean; emitEvent?: boolean } = {}): void {\n        if (!value) {\n            return;\n        }\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const model = this._models.find(x => x.name === key);\n            this.controls[key].patchValue(value[model.key], { onlySelf: true, emitEvent: options.emitEvent });\n        }\n\n        this.updateValueAndValidity(options);\n    }\n\n    public getRawValue(): T {\n        const rawValue = new this.config.instance();\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            rawValue[model.key] = control.getRawValue();\n        }\n\n        return rawValue;\n    }\n\n    public getValidValue(): T {\n        const validValue = new this.config.instance();\n\n        for (const key in this.controls) {\n            if (!this.controls.hasOwnProperty(key)) {\n                continue;\n            }\n\n            const control = this.controls[key];\n            const model = this._models.find(x => x.name === key);\n            validValue[model.key] = control.getValidValue();\n        }\n\n        return validValue;\n    }\n\n    public shouldValidate(): boolean {\n        let parentValidation = true;\n        if (this.parent) {\n            parentValidation = (this.parent as any as GeneratedControl).shouldValidate();\n        }\n        if (!this.config) {\n            return true;\n        }\n        return (this.config.validationOption || { isOptional: false }).isOptional ? false : parentValidation;\n    }\n\n    public copy(): GeneratedFormGroup<T> {\n        const group = new GeneratedFormGroup<T>();\n        group.setConfig(this.config);\n        return group;\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private generateControls() {\n        for (const control of this._models) {\n            let formControl: AbstractControl;\n            if (control.formElementType === \"array\") {\n                formControl = new GeneratedFormArray(control as ArrayModel, this.asyncValidators);\n            } else if (control.formElementType === \"group\") {\n                formControl = new GeneratedFormGroup(this.asyncValidators);\n                (formControl as GeneratedFormGroup<T>).setConfig(control as GroupModel);\n            } else {\n                formControl = new GeneratedFormControl(control, this.asyncValidators);\n                (formControl as GeneratedFormControl<any>).setAsyncControlValidators((control as ControlModel).asyncValidators);\n            }\n            super.addControl(control.name, formControl);\n        }\n    }\n}\n\nexport class GeneratedFormArray<T> extends FormArray implements GeneratedControl {\n    public controls: GeneratedControl[];\n\n    constructor(private model: ArrayModel, private asyncValidators: AsyncValidator[] = []) {\n        super(model.defaultValue ?? [], model.validators);\n    }\n\n    public push(value: unknown | T): void {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.push(control);\n    }\n\n    public insert(index: number, value: unknown | T): void {\n        const control = this.getControl();\n        if (value) {\n            control.patchValue(value);\n        }\n        super.insert(index, control);\n    }\n\n    public at(index: number): GeneratedControl {\n        return super.at(index) as GeneratedControl;\n    }\n\n    public patchValue(value: T[], options: { onlySelf?: boolean; emitEvent?: boolean } = {}): void {\n        if (!value) {\n            return;\n        }\n\n        let i = 0;\n        for (const data of value) {\n            if (i >= this.controls.length) {\n                this.push(null);\n            }\n            this.at(i).patchValue(data, { onlySelf: true, emitEvent: options.emitEvent });\n            ++i;\n        }\n\n        this.updateValueAndValidity(options);\n    }\n\n    public getRawValue(): T[] {\n        return this.controls.map(x => x.getRawValue());\n    }\n\n    public getValidValue(): T[] {\n        return this.controls.map(x => x.getValidValue());\n    }\n\n    public shouldValidate(): boolean {\n        if (this.parent) {\n            return (this.parent as any as GeneratedControl).shouldValidate();\n        }\n        if (!this.model) {\n            return true;\n        }\n        return (this.model.validationOption || { isOptional: false }).isOptional;\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private getControl(): AbstractControl {\n        if (this.model.children) {\n            const group = new GeneratedFormGroup();\n            group.setConfig({\n                ...this.model,\n                instance: this.model.arrayType\n            });\n            return group;\n        }\n\n        const formControl = new GeneratedFormControl({\n            ...this.model,\n            type: (this.model.arrayType as () => void).name\n        }, this.asyncValidators);\n        formControl.setAsyncControlValidators((this.model as ControlModel).asyncValidators);\n        return formControl;\n    }\n}\n\nexport class GeneratedFormControl<T> extends FormControl implements GeneratedControl {\n    constructor(private model: ControlModel, private asyncValidators: AsyncValidator[] = []) {\n        super(model.defaultValue, model.validators);\n    }\n\n    public getRawValue(): T {\n        switch (this.model.type) {\n            case \"Number\":\n                if (this.value === null || this.value === undefined) {\n                    return this.value;\n                }\n\n                if (this.model.validationOption && this.model.validationOption.ignoreZero && +this.value === 0) {\n                    return;\n                }\n\n                return +this.value as any;\n            case \"String\":\n                if (this.model.validationOption && this.model.validationOption.ignoreEmpty && this.value === \"\") {\n                    return;\n                }\n\n                return this.value;\n            default:\n                return this.value;\n        }\n    }\n\n    public getValidValue(): T {\n        if (this.invalid) {\n            return undefined;\n        }\n\n        return this.getRawValue();\n    }\n\n    public shouldValidate(): boolean {\n        if (this.parent) {\n            return (this.parent as any as GeneratedControl).shouldValidate();\n        }\n\n        if (!this.model) {\n            return true;\n        }\n        return !(this.model.validationOption || { isOptional: false }).isOptional;\n    }\n\n    public setAsyncControlValidators(validators: ControlAsyncValidators[]): void {\n        if (validators && validators.length) {\n            this.setAsyncValidators(validators.map(x => this.customAsyncValidator.bind(this, x)));\n        }\n    }\n\n    public markAllAsTouched() {\n        super.markAllAsTouched();\n        (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    private customAsyncValidator(controlValidator: ControlAsyncValidators, control: AbstractControl) {\n        if (!this.asyncValidators) {\n            return of(null);\n        }\n\n        const validator = this.asyncValidators.find(x => controlValidator.name === x.name);\n        if (!validator) {\n            return of(null);\n        }\n\n        return validator.validate(control);\n    }\n}\n","export const CONTROLS = \"__CONTROLS__\";\nexport const CONTROL = \"__CONTROL[{name}]__\";\n","import \"reflect-metadata\";\nimport { ControlModel } from \"./models/control.model\";\nimport { CONTROL, CONTROLS } from \"./constant\";\n\nexport class NgxFormGeneratorScanner {\n    public static getControls(model: any): ControlModel[] {\n        const controls = Reflect.getMetadata(CONTROLS, model.prototype) as string[];\n        return controls.map(x => this.getControl(x, model));\n    }\n\n    public static getControl(name: string, model: any): ControlModel {\n        return Reflect.getMetadata(CONTROL.replace(\"{name}\", name), model.prototype);\n    }\n}\n","import { GeneratedFormGroup } from \"./forms\";\nimport { GroupModel } from \"./models/group.model\";\nimport { NgxFormGeneratorScanner } from \"./ngx-form-generator.scanner\";\nimport { AsyncValidator } from \"./validators/async.validator\";\n\nexport function ngxFormGeneratorFactory(provider: any) {\n    return (asyncValidators: AsyncValidator[]) => {\n        const group = new GeneratedFormGroup(asyncValidators);\n        group.setConfig({\n            instance: provider,\n            children: NgxFormGeneratorScanner.getControls(provider)\n        } as GroupModel);\n        return group;\n    };\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { ArrayModel } from \"../models/array.model\";\n\n// @dynamic\nexport class ArrayHandler {\n    public static setup(type: () => void): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let array: ArrayModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const children = Reflect.getMetadata(CONTROLS, type.prototype) as string[];\n            if (!array) {\n                const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            array = {\n                name: propertyKey,\n                key: propertyKey,\n                formElementType: \"array\",\n                type: \"Array\",\n                validators: array?.validators ?? [],\n                arrayType: type,\n                children: children ? children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), type.prototype)) : null\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), array, target);\n        };\n    }\n}\n","import { ArrayHandler } from \"../../handlers/array.handler\";\n\nexport function Array(type: object): PropertyDecorator {\n    return ArrayHandler.setup(type as () => void);\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { ControlConfigModel, ControlModel } from \"../models/control.model\";\n\n// @dynamic\nexport class ControlHandler {\n    public static setup(config: ControlConfigModel = {}): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let control: ControlModel = this.getControl(target, propertyKey);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            control = {\n                ...control,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                type: controlType.name,\n                defaultValue: config.defaultValue\n            };\n            this.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static getControl(target: object, propertyKey: string): ControlModel {\n        let control: ControlModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n        if (!control) {\n            control = {\n                name: null,\n                key: null,\n                formElementType: \"control\",\n                type: null,\n                validators: [],\n                asyncValidators: []\n            };\n            const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n            controls.push(propertyKey);\n            Reflect.defineMetadata(CONTROLS, controls, target);\n        }\n\n        return control;\n    }\n\n    public static saveControl(control: ControlModel, target: object, propertyKey: string) {\n        Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), control, target);\n    }\n}\n","import { ControlHandler,  } from \"../../handlers/control.handler\";\nimport { ControlConfigModel } from \"../../models/control.model\";\n\nexport function Control(config?: ControlConfigModel): PropertyDecorator {\n    return ControlHandler.setup(config);\n}\n","import \"reflect-metadata\";\nimport { CONTROL, CONTROLS } from \"../constant\";\nimport { GroupConfigModel, GroupModel } from \"../models/group.model\";\n\n// @dynamic\nexport class GroupHandler {\n    public static setup(config: GroupConfigModel = {}): PropertyDecorator {\n        return (target: object, propertyKey: string) => {\n            let group: GroupModel = Reflect.getMetadata(CONTROL.replace(\"{name}\", propertyKey), target);\n            const controlType = Reflect.getMetadata(\"design:type\", target, propertyKey);\n            const children = Reflect.getMetadata(CONTROLS, controlType.prototype) as string[];\n            if (!group) {\n                const controls: string[] = Reflect.getMetadata(CONTROLS, target) || [];\n                controls.push(propertyKey);\n                Reflect.defineMetadata(CONTROLS, controls, target);\n            }\n            group = {\n                ...group,\n                instance: controlType,\n                name: config.name || propertyKey,\n                key: propertyKey,\n                formElementType: \"group\",\n                type: controlType.name,\n                defaultValue: config.defaultValue,\n                children: children.map(x => Reflect.getMetadata(CONTROL.replace(\"{name}\", x), controlType.prototype))\n            };\n            Reflect.defineMetadata(CONTROL.replace(\"{name}\", propertyKey), group, target);\n        };\n    }\n}\n","import { GroupHandler } from \"../../handlers/group.handler\";\nimport { GroupConfigModel } from \"../../models/group.model\";\n\nexport function Group(config?: GroupConfigModel): PropertyDecorator {\n    return GroupHandler.setup(config);\n}\n","import { ValidationErrors, ValidatorFn } from \"@angular/forms\";\nimport { GeneratedControl } from \"../forms\";\n\nexport function validationWrapper(fn: ValidatorFn): ValidatorFn {\n    return (control: GeneratedControl): ValidationErrors | null => {\n        if (control.shouldValidate()) {\n            return fn(control);\n        }\n\n        return null;\n    };\n}\n","import \"reflect-metadata\";\nimport { ValidatorFn } from \"@angular/forms\";\nimport { ControlAsyncValidators, ControlModel } from \"../models/control.model\";\nimport { validationWrapper } from \"../validators/validator-wrapper\";\nimport { ControlHandler } from \"./control.handler\";\n\n// @dynamic\nexport class ValidatorsHandler {\n    public static setup(fn: ValidatorFn) {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validators.push(validationWrapper(fn));\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static setupAsync(validator: ControlAsyncValidators) {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.asyncValidators.push(validator);\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static isOptional() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                isOptional: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static ignoreZero() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreZero: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n\n    public static ignoreEmpty() {\n        return (target: object, propertyKey: string) => {\n            const control: ControlModel = ControlHandler.getControl(target, propertyKey);\n            control.validationOption = {\n                ...(control.validationOption || {}),\n                ignoreEmpty: true\n            };\n            ControlHandler.saveControl(control, target, propertyKey);\n        };\n    }\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function arrayMaxLength(max: number, checkNull = true): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (control.value instanceof Array) {\n            if (control.value.length <= max) {\n                return null;\n            }\n\n            return {\n                arrayMaxLength: true\n            };\n        }\n\n        if (!control.value && checkNull) {\n            return {\n                arrayMaxLength: true\n            };\n        }\n\n        return null;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function arrayMinLength(min: number, checkNull = true): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (control.value instanceof Array) {\n            if (control.value.length >= min) {\n                return null;\n            }\n\n            return {\n                arrayMinLength: true\n            };\n        }\n\n        if (!control.value && checkNull) {\n            return {\n                arrayMinLength: true\n            };\n        }\n\n        return null;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function customPattern(regex: RegExp, error: ValidationErrors): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (!control.value) {\n            // if control is empty return no error\n            return null;\n        }\n\n        // test the value of the control against the regexp supplied\n        const valid = regex.test(control.value);\n\n        // if true, return no error (no error), else return error passed in the second parameter\n        return valid ? null : error;\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function matches(otherControlName: string): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        if (!control.parent || !control.parent.controls[otherControlName]) {\n            return null;\n        }\n        const error = `${otherControlName}_mismatch`;\n        return control.parent.controls[otherControlName].value === control.value ? null : { [error]: true };\n    };\n}\n","import { AbstractControl, ValidationErrors, ValidatorFn } from \"@angular/forms\";\n\nexport function valueIs(expected: any): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n        const actual = control.value;\n        if (actual === null || actual === undefined) {\n            return null; // Don't validate null values to allow optional controls.\n        }\n\n        return actual !== expected ? { valueIs: { actual, expected } } : null;\n    };\n}\n","import { AbstractControl, ValidationErrors } from \"@angular/forms\";\nimport { Observable } from \"rxjs\";\n\nexport abstract class AsyncValidator {\n    public abstract name: string;\n    public abstract validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ArrayMaxLength(max: number, checkNull = true): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.arrayMaxLength(max, checkNull));\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ArrayMinLength(min: number, checkNull = true): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.arrayMinLength(min, checkNull));\n}\n","import { ValidationErrors } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function CustomPattern(regex: RegExp, error: ValidationErrors): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.customPattern(regex, error));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Email(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.email);\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function IgnoreEmpty(): PropertyDecorator {\n    return ValidatorsHandler.ignoreEmpty();\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function IgnoreZero(): PropertyDecorator {\n    return ValidatorsHandler.ignoreZero();\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function MatchesControl(controlName: string): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.matches(controlName));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MatchesPattern(pattern: string | RegExp): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.pattern(pattern));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Max(max: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.max(max));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MaxLength(max: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.maxLength(max));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Min(min: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.min(min));\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function MinLength(min: number): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.minLength(min));\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Optional(): PropertyDecorator {\n    return ValidatorsHandler.isOptional();\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function Required(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.required);\n}\n","import { Validators } from \"@angular/forms\";\nimport { ValidatorsHandler } from \"../../handlers/validators.handler\";\n\nexport function RequiredTrue(): PropertyDecorator {\n    return ValidatorsHandler.setup(Validators.requiredTrue);\n}\n","import { ValidatorsHandler } from \"../../handlers/validators.handler\";\nimport * as validators from \"../../validators\";\n\nexport function ValueIs(expected: any): PropertyDecorator {\n    return ValidatorsHandler.setup(validators.valueIs(expected));\n}\n","import { ValidatorsHandler } from \"../handlers/validators.handler\";\nimport { ControlAsyncValidators } from \"../models/control.model\";\n\nexport function registerAsyncValidatorDecorator(validator: ControlAsyncValidators) {\n    return ValidatorsHandler.setupAsync(validator);\n}\n","/*\n * Public API Surface of form-generator\n */\n\nimport { ClassProvider, FactoryProvider, ModuleWithProviders, NgModule, Provider, ValueProvider } from \"@angular/core\";\nimport { FormsModule, ReactiveFormsModule } from \"@angular/forms\";\nimport { GeneratedFormGroup } from \"./lib/forms\";\nimport { ngxFormGeneratorFactory } from \"./lib/ngx-form-generator.factory\";\nimport { NGX_FORM_GENERATOR_ASYNC_VALIDATORS } from \"./lib/validators/constant\";\n\nexport interface NgxFormGeneratorOptions {\n    asyncValidators?: Provider[];\n}\n\n// @dynamic\n@NgModule({\n    imports: [FormsModule, ReactiveFormsModule]\n})\nexport class NgxFormGeneratorModule {\n    public static forRoot(options: NgxFormGeneratorOptions = {}): ModuleWithProviders<NgxFormGeneratorModule> {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: options?.asyncValidators?.map((provider) => {\n                const p = {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    multi: true\n                } as Provider;\n                if ((provider as FactoryProvider).useFactory) {\n                    (p as FactoryProvider).useFactory = (provider as FactoryProvider).useFactory;\n                    (p as FactoryProvider).deps = (provider as FactoryProvider).deps;\n                } else {\n                    (p as ClassProvider).useClass = (provider as ClassProvider).useClass ?? provider as any;\n                }\n                return p;\n            }) ?? [\n                {\n                    provide: NGX_FORM_GENERATOR_ASYNC_VALIDATORS,\n                    useValue: []\n                }\n            ]\n        };\n    }\n\n    public static forFeature(providers: Provider[]): ModuleWithProviders<NgxFormGeneratorModule> {\n        return {\n            ngModule: NgxFormGeneratorModule,\n            providers: providers.map(provider => ({\n                provide: (provider as ValueProvider).provide || GeneratedFormGroup,\n                useFactory: ngxFormGeneratorFactory((provider as ValueProvider).useValue || provider)\n            }))\n        };\n    }\n}\n\n// @dynamic\nexport class NgxFormGeneratorProvider {\n    public static forFeature(providers: Provider[]): Provider[] {\n        return providers.map(provider => ({\n            provide: (provider as ValueProvider).provide || GeneratedFormGroup,\n            useFactory: ngxFormGeneratorFactory((provider as ValueProvider).useValue || provider),\n            deps: [NGX_FORM_GENERATOR_ASYNC_VALIDATORS]\n        }));\n    }\n}\n\nexport * from \"./lib/decorators\";\nexport * from \"./lib/forms\";\nexport * from \"./lib/validators\";\nexport * from \"./lib/ngx-form-generator.factory\";\nexport * from \"./lib/handlers/validators.handler\";\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["Optional","Array","validators.arrayMaxLength","validators.arrayMinLength","validators.customPattern","validators.matches","validators.valueIs"],"mappings":"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"}}}